让我为您翻译这段关于 Minecraft 模组开发的文本： 让我们来讨论新的数据组件系统和物品堆叠.
Minecraft 模组开发课程现已上线，包含超过 11 小时的内容，涵盖从基础知识到方块实体和自定义生物的所有内容.
在本教程中，我们将探讨 Minecraft 最新版本中引入的新数据组件系统.
这个系统某种程度上是 NBT 数据系统的继任者，但并不完全是，因为 NBT 数据仍然在 Minecraft 中广泛使用，而数据组件系统实际上是向后兼容的.
 如果我们按两次 Shift 键并查找数据组件类（Components），您会看到存在于原版游戏中的不同数据组件.
其中第一个是自定义数据（custom data），理论上您可以直接使用这个自定义数据.
如果我们按住 Ctrl 并点击进入，您可以看到它有一个复合标签，也就是 NBT 数据.
如果您想继续使用复合标签（NBT 数据），您完全可以直接使用这里的自定义数据.
 不过，我们不会这样做.
我们要做的是创建一个或多或少完全自定义的数据类型，用于保存坐标.
具体来说，当我使用凿子物品时，我想在右键点击方块时保存方块数据，并将其显示为悬浮文本.
这不是什么太复杂的功能，但它很好地展示了组件系统的用法.
 让我们在教程模组包中创建一个名为 component 的新包，并在其中创建一个名为 ModDataComponents 的新 Java 类.
这会很有趣，我们也可以将其称为 ComponentTypes，但我认为现在这样就可以了.
这个类将包含一个 public static final DeferredRegister，类型为 DataComponentType 的数据组件类型.
 让我为您翻译这段文本： 我们可以看到它在这里为我们提供了数据组件类型建议.
这是教程模组（tutorial mod）的 modid.
在这里我们要有一个 public static void register 方法，该方法需要一个 IEventBus 参数.
我们将把特定的 DeferredRegister 传入事件总线中.
当然，所有代码都可以在下方找到，所以完全不用担心.
然后在这里，我们只需调用 ModDataComponents.register 并传入 ModEventBus，之后我们就可以添加数据组件了.
这非常实用，确实很好.
在这种情况下，我们会有一个辅助方法来帮助我们注册组件，这是一个 private static 方法，带有泛型参数 T，然后是非常重要的 DeferredHolder，类型是 DataComponentType 和第二个参数是 DataComponentType.
看起来有点复杂，但很快就会明白.
这将是带有字符串名称参数的 register 方法，第二个参数是 DataComponentType.Builder 类型的运算符.
 让我帮你翻译这段文本： 类型为 question 的 builder 实际上是 T 类型的 Builder 运算符.
新的 Forge 文档非常有用，帮助我理解了这个有点复杂的概念（我会在下方附上链接）.
在这里，我们只需要返回 data component types.register，传入 name 参数，然后是一个 Builder 运算符的 supplier，用于应用 data component type.
 注：我保留了一些专业术语如 "Builder"、"Forge"、"supplier" 等的原文形式，因为这些是编程领域的特定术语.
这段翻译保持了原文的技术含义，同时让中文读者更容易理解上下文.
 让我为您翻译这段关于《Immersive Translate》的技术文档内容： 这次构建器的方法在第二个结束括号之后调用 build 方法，这里再次可以看到，每次都会有相同的设置.
你会有这个特定的类，然后可以根据需要为任意数量的数据添加多个延迟持有者（deferred holders）.
在这个例子中，我们将为坐标添加一个，你将看到这一点.
 我们要创建一个 public static final 的延迟持有者，类型是数据组件类型（data component type），带有问号的泛型参数.
延迟持有者的第二个参数将是数据组件类型，这里我们要指定数据组件应该是什么类型.
 如果我们检查这个 St，理论上它可以是任何你想要的类型，但是组件类型必须基于编解码器（codec）.
这意味着理论上我们可以放入一个整数，然后使用整数编解码器；我们可以放入一个区块位置（block pos）然后使用区块位置编解码器；我们甚至可以放入一个自定义类，只要该自定义类有编解码器（当然这需要我们自己编写）.
 在这个例子中，这将是坐标，我们要在坐标下注册这个.
第二个参数将是构建器，然后指向 Builder.
你可以看到我们有三个不同的选项：persistent、Network synchronized 和 build，我们也可以缓存编码（强烈推荐）.
让我们在这里使用 persistent，然后在 persistent 中使用 block pos.
 让我为您翻译这段关于 Minecraft 模组开发的技术内容： 通过 codec 并以分号结束，您可以看到它是如何工作的.
这就是我们需要做的全部，现在它基本上知道了我们可以通过这些坐标添加的数据组件将是一个方块位置，并且将通过这个 codec 进行序列化.
如果我们实际查看这个特定内容，可以看到这是一个输入流，看起来很复杂 - 这就是 codec 的特性，它们确实比之前的序列化方式更复杂.
 但现在我们该如何使用它呢？您可能会说：等等，这太简单了！是的，确实非常简单.
实际上，在 use on 方法中，我们只需要获取 ItemStack.
 在上一个教程中，我们讨论了 BlockStates 和 BlockState 属性.
在我们的 mod blocks 中，比如这里的 bisou lamp（比索灯），我们创建了一个 Bismo Lamp Block 类的实例.
虽然我们只创建了一个类实例，但我们可以放置数百万个比索灯，它们在世界中都是不同的，因为它们都是不同的 BlockStates.
 同样的原理也适用于物品栈和物品.
以这个凿子物品为例，我们在这里只创建了一次，这个类只被实例化一次.
但是，如果我在物品栏中有三个不同的凿子，它们都会受到不同的耐久损耗，因为它们是不同的 ItemStack.
再次强调，ItemStack 是物品的实例，这是一个非常重要的区别.
因此，在 use on 方法中，我们需要通过 context 来获取 ItemStack.
 让我为您翻译这段文本： 获取手中的物品，这基本上就是我们可以悬停的物品堆叠.
你可以看到这里和这里都有一个物品堆叠.
调用 doSet 方法非常简单，你需要为它提供一个数据组件类型和一个值.
数据组件类型将是 data mod data components.coordinates，然后我们给它实际的类型，也就是一个方块位置，即 context.getClickPosition.
通过这行代码，我们现在已经在这个特定的物品堆叠上保存了我们的自定义数据，它被称为坐标.
这就是我们刚才所做的，就是这么简单.
你可能会说这太疯狂了，这怎么可能？是的，就是这么简单.
现在我要做的是，当我们有这个数据时，如果上面有一些数据，我就添加一个悬停文本来读取它.
这很容易实现：在这里，我们再次可以访问堆叠，所以我们要说，如果我们悬停的堆叠 doGet，然后我们要获取 mod data components.
 让我帮你翻译这段文本： 如果坐标不为空（因为这是可空的），我们实际上可以再次进行双重检查.
如果你按住 Control 键并左键点击，我们可以看到这是可空的，这意味着如果在这个堆栈上没有这种特定类型的数据，它就会返回 null.
所以如果它不为空，我们就知道在这个特定的堆栈上确实存在某种坐标类型的数据.
因此，对于这个数据组件类型，我们接下来要调用 tooltip components.add，在这种情况下，我们只需在这里使用一个字面量 trans，一个字面值表示"最后一个方块改变于"，这将是 stack.
 注：保留了技术术语如 null、Control、tooltip components.add、trans 等的原文形式，以保持专业准确性.
这段翻译超过 180 字符，并保持了原文的技术含义.
 让我为您翻译这段关于《Immersive Translate》中数据组件相关的技术内容： 再次使用 get 方法，这次我们要获取实际的数据，即 mod 数据组件中的坐标信息.
它会立即创建并使其成为一个块暂停，然后当我们将鼠标悬停在凿子上时添加这些信息.
这就是我们需要做的全部内容.
我们只需要知道 set 方法和 get 方法，这里的 set 是可空的，意味着如果你想重置数据，可以传入 null 值.
 说到数据组件的复杂性，它们其实相当简单.
在数据组件类中有许多可供使用的组件，其中自定义数据特别有趣，因为它包含了一个复合标签，可以包含我们之前使用的所有内容 - 包括字节、短整型等所有数据类型.
你可以直接将这些放入自定义数据中，它会立即生效，甚至不需要额外配置.
 回到 Minecraft 游戏中，你可以看到我这里有一些凿子.
目前我还没有点击任何东西，所以没有发生任何变化.
但是当我右键点击任何方块时，现在将鼠标悬停在上面，就会显示最后更改的方块位置.
这个位置会随着点击不同位置而改变，比如从(-26, -105)变成(9, -19, -98).
其他凿子没有这个信息，因为我们只对右键点击的那个物品执行了这个操作.
 新的数据组件系统确实很酷，它比我想象的要直观得多.
起初我以为这会很复杂，但实际上非常简洁.
Neo Forge 关于数据组件的文章会在描述中提供链接，这是一个极其宝贵的资源.
下一期视频我们将讨论自定义工具