让我帮你翻译这段文本： 让我们将我们的 Neo 项目更新到 1.21.3.
这个长达 11 小时以上的 Minecraft 模组开发课程现已开放，内容涵盖从基础知识到方块实体和自定义生物的所有内容.
好的，让我们回到之前的内容，在本教程中，我们将把项目更新到 1.
 这段翻译保留了专有名词如 "Neo"、"Minecraft" 等.
我注意到原文最后一句似乎被截断了，所以翻译也相应地保持了这种不完整性.
翻译时我尽量保持了原文的语气和技术术语的准确性，同时确保中文表达通顺自然.
 非常重要的免责声明：在开始之前，本教程系列的剩余部分将继续使用 1.21.1 版本.
我之前在 YouTube 频道上就此进行了投票调查，很多人表示完全不需要制作更新视频，但仍有约 25%的人希望看到更新相关的内容，所以我们将制作一期更新视频，然后继续使用 1.21.1 版本.
 这点很重要：我基本上不建议你进行这次更新.
如果你一定要更新，建议创建一个单独的分支，这样就不会破坏你的项目.
因为这次更新涉及很多变动，有些改动可能会造成不可逆的影响.
所以强烈建议如果要更新的话，在不同的分支上进行尝试.
 关于更新需要做的几件事：首先要去 Gradle 配置文件，将版本改为 2.3.8-beta.
这样应该就可以了.
这里的版本范围我们可以直接改为 1.22，这样就没问题了.
然后这个是 1.
 让我为您翻译这段关于 Minecraft 模组开发的技术说明： 在这里 21.3 版本基本没问题，接下来我们需要修改 build.gradle 文件，把版本号改为 21，因为 mod 定义那边用的是 21 版本.
完成这个更改后，我们可以加载 gradle 的变更，这会下载新的相关内容.
然后就让我们开始这个"折磨"的过程吧，说实话其实也没那么糟.
我承认确实有一些有趣的改动，但很多变化都比较特别.
 首先，在我们的 ModBlocks 类中，现在每个方块都需要一个注册键（registry key）或 ID.
在属性设置中，我们现在可以调用 setID 方法，这个方法需要一个 resource key 参数.
它会像这样为每个方块进行查找：setID(ResourceKey.create(Registries.BLOCK))，然后我们需要用命名空间和路径创建一个 resource location，即"tutorialmod".
 注：保留了技术术语如 build.gradle、ModBlocks、registry key、setID、ResourceKey、Registries.BLOCK 等专业词汇的原文形式.
 让我为您翻译这段关于 Minecraft 模组开发的技术讨论： 模组 ID 需要与我们注册方块时使用的名称完全一致.
这个调用必须对每个方块都执行.
虽然我完全同意我们可以在 register block 方法中实现这点，也可以在那里传入设置参数，但在我们的情况下，由于方块数量不多，我们就简单地为所有方块都添加这个设置.
这种方式可能不够面向未来，不过目前这样做问题不大.
 接下来我们回到 register block，这里也需要为方块物品设置 ID.
我们需要创建一个包含 create、Registries.ITEM、命名空间和路径的资源键，其中使用 tutorial mod 的 mod ID 和对应名称.
这个过程需要为每个不同的方块物品重复执行.
 我们只需复制这个 setID 调用，在每个 of 方法之后粘贴即可.
有时我会添加换行以提高可读性，因为这段代码比较长.
如果你觉得重复使用这些信息很奇怪，确实如此.
说实话，我对这次更新有些担忧，代码变更确实有点奇怪.
虽然有一些好的改进，但优缺点都需要权衡.
 复制完成后，非常重要的一点是要修改资源键中的名称，使其与方块的实际名称相匹配.
我通常是双击选中名称，用 Ctrl+C 复制，然后用 Ctrl+V 粘贴到正确位置.
这个过程对所有方块和物品都要执行.
 虽然通过自定义 register block 方法可以简化这个过程，但我现在选择不这么做.
我承认这显示了我对这次更新的偏见，但我觉得这样也没问题.
这就是 mod blocks 方法需要做的全部工作了，接下来我们可以继续进行数据生成.
 关于 trim material 类的移动，我们只需要重新导入即可.
在下面，我们会做一些有趣的改动.
代码可以在 29 update 1213 中找到.
由于装备物品不再有装备槽位可用，我们需要改变装甲类型的判断方式，改用检查名称中是否包含"helmet"这样的方式.
我知道这种方法可能不够优雅，但目前就这样处理吧.
 最后，关于配方提供器（mod recipe provider）有一些变化，但总体来说变化不大.
我们需要一个新的构造函数，实现 buildRecipes 方法.
我们可以直接删除参数，使用 this 来替代之前的 recipeOutput.
 让我将这段文本翻译为简体中文： 我要做的是选中这段内容并按下 Ctrl+R，然后我们要替换这个...让我们选择这个并把输出放在这里，然后替换所有这些内容.
好消息是我们甚至不需要对所有内容都这样做，因为在这些情况下 - 比如对于台阶，我们不再需要它了；对于压力板，也不再需要了；墙体不需要，锻造台修整也不再需要.
 这就是下一个变化，这里也稍有改动，我们不再放入资源位置（resource location），而是这次要放入资源键（resource key）.
在这种情况下是 create Registries do recipe，然后下一个参数将完全是这个，不过这里要进行解析，这将用于以下内容：要传入 mod items 的 get item name，这是 C smithing template...不，是 count smithing template，然后加上加号，这里的加号将是下划线加 smithing 再加下划线加 trim，然后需要再加一个结束括号.
 对于这些情况，非常简单，只需删除 class，然后它就能工作了.
接下来我们需要一个辅助方法，这将是一个 public static class，或者实际上是一个继承自 recipe provider 的辅助类.
 以下是该段文本的中文翻译： Runner 将要实现一个或两个方法，这里的名称可以就叫做"my recipes"或类似的名字.
recipe provider 将成为新的 mod recipe provider，传入我们在这里可以访问的 provider 和 recipe output.
然后我们需要在这里添加一个新的构造函数，我们可以简单地将鼠标悬停在这上面来创建与父类匹配的构造函数.
我们要把这里改成 pack output，当然这里也要相应更改，这里又是 provider，是的，provider 没问题，我们不需要改动.
就是这样，我们还要把这个改成 public.
然后在数据生成器中，我们不再使用 mod recipe provider，而是要在这里切换并实际将其改为新的 mod recipe provider.
 这段文本的中文翻译如下： Runner，这样应该就可以了.
现在我们还想改变下面这部分，也就是这里的 has 方法，我们只想把所有这些都改成非静态的，然后突然间一切就都能正常工作了，mod 配方提供器就完成了.
像往常一样，代码也在下面提供.
接下来我们要继续处理物品部分，哦，物品部分会很有趣.
凿子物品能正常工作吗？我们会看看情况如何，但应该没问题.
锤子物品我们稍后再处理.
燃料物品也需要修改，是的，这里有一个新的 getBurnTime 方法，它只包含燃料值，所以我们只需要重写这个方法，并在这里返回燃烧时间，这很简单.
mod 装备物品我们也会稍后处理，当我们讨论装备物品时再说，因为首先要处理 mod 物品.
正如你所见，大量的红色错误正对着我们微笑.
和方块一样，我们需要在这里调用 setId 方法，使用 resource key.
 让我将这段较为混乱的文本整理并翻译为简体中文： 这段内容主要讨论了 Registries（注册表）的创建和使用过程.
具体来说： 1. 从命名空间和路径创建物品的资源位置，需要使用 mod ID，在本例中是 "bismo".
理论上可以创建一个辅助方法来简化这个过程，但作者选择了直接在各处使用相同的代码片段.
 2. 需要将这段代码添加到所有不同的剑、斧和工具中.
对于装备物品，不再需要耐久度参数，可以直接删除并替换为新的代码.
 3. 动物装甲物品的修复相对简单，只需删除 "false" 参数即可.
Bismo 装甲材质也需要进行相应修改.
 4. 锻造模板需要特别处理： - 现在需要新的物品属性设置 - 需要使用 Registry 的资源位置或资源键 - 不再需要之前的 C 相关代码 5. 作者提到这些更改完成后就不需要重复操作了，并表示会在描述中提供 GitHub 仓库链接和 NeoForge 的变更摘要，其中包含了所有改动的详细说明.
 这些修改主要涉及游戏物品注册系统的重构，使其更符合新版本的要求和规范.
 让我为您翻译这段文本.
由于原文是一段口语化的游戏开发讲解，我会将其整理成更清晰的中文表述： 这里的类型现在变成了护甲类型，看起来还算直观，问题不大.
第一个出现不同错误的原因是因为这是我们的护甲物品，稍后我会修复这个问题.
 首先，我们要处理剑和其他工具.
基本上，你需要处理之前的工具属性：把包含 5 个逗号及其后续内容剪切出来（使用 Ctrl+X），然后将其粘贴到剑物品构造函数中第一个逗号之后，并在这里添加一个逗号.
然后我们可以删除属性调用，就这样设置好了.
 现在应该只有 mod 工具 TI bismuth 会报错，这是预期的，其他都没问题.
我们需要对其余部分都进行相同的处理.
 说实话，这确实是个相当大的更新.
某些方面确实改进了，比如这种属性处理方式就更好了 - 我都不知道他们最初为什么要用那种奇怪的创建属性的方式.
但问题是，要让所有东西正常运行仍然需要大量工作，这有时确实很烦人.
 作为模组开发者，我们不得不适应这些变化.
我们某种程度上受制于 Mojang 的决定 - 当他们想改变什么的时候，他们就会改变，并不会特别考虑这对模组开发者是好是坏.
说实话，我们在他们的优先级列表中排得很后面.
 不管怎样，现在我们可以查看 mod 工具层级，会发现原来的层级不再存在，因为这现在变成了工具材料.
我们可以将其改为新的工具材料，修复用的原料不再是 ingredient（材料），而是变成了 tag（标签）.
 让我来翻译这段文本： 物品.
当然 mod 标签会处理物品.
这里是比斯莫修复（Bismore Repair），我们就简单地称之为比斯莫修复就可以了.
让我们到这里的 mod 标签，比索修复（Bisou Repair）、比斯莫修复，然后我们马上要去我们的物品标签提供器中添加这个，这将是 mod 标签.物品.
 注： - 保留了专有名词 "Bismore Repair"、"Bisou Repair" 的原文 - "mod" 作为技术术语保持不变 - 翻译时保持了原文的口语化表达风格 - 确保翻译长度超过 180 字符 - 对模糊的技术术语采用了意译加原文保留的方式 让我为您翻译这段关于《Immersive Translate》mod 开发的技术内容： 铋修复模组物品，我们可以使用铋来修复我们的铋工具等级，这应该很容易理解，没什么特别复杂的.
现在所有工具都能正常工作，除了锤子，因为它在这里是一个自定义类，我们还没有处理它.
 接下来我们要做的是，在 Digger 物品上点击鼠标中键，我们将获取所需的所有参数.
然后我们要把这里改成材料（material），并在这里传入材料参数.
标签键（tag key）我们不需要，因为我们已经在第一个参数中传入了.
如果我没记错的话，这里的第一个是攻击伤害（attack damage），第二个是攻击速度（attack speed），这两个都必须在标签之后传入.
所以这是攻击伤害、攻击速度，最后是属性（properties），我们也要改变它的名称.
 完成后，按 Control+Alt+O 删除所有不再需要的导入，这样锤子物品也完成了，没有更多问题了.
 接下来要处理的是模组护甲材料.
幸运的是，这些实际上已经改变得更好了.
首先，不再需要等待，而且我们也不再需要这个疯狂的辅助方法了，这是两个很大的改进.
不再需要注册方法，只需要新的护甲材料，第一个参数是耐久度，然后我们就可以使用这个新的护甲物品了.
 让我来翻译这段文本： 在这里输入护甲类型，然后我们就可以为所有的项目进行更改.
按住 Control 键和 Alt 键，这样就可以在这里统一修改所有的名称，这样做没问题.
然后我们这里还有一个标签，我们要设置的是 mod 标签.
items. bismi repair，最后一个是一个资源位置，包含了命名空间和通向我们 mod 的路径.
 让我为您翻译这段文本的主要内容： 这段内容主要讨论了一个名为"Bismuth"的 Minecraft 模组的代码更新和适配工作.
主要涉及以下几个方面： 1. 装备系统的改动： - 更新了装备音效和附魔声音的实现 - 修改了护甲材质系统的实现方式 - 新增了 equipable 数据组件的处理 2. 材质和资源文件的变更： - 调整了材质文件的目录结构，新增了 equipment 文件夹 - 重组织了模型文件的存放位置 - 更新了 humanoid 和 horse 相关的材质路径 3. 食物系统的改进： - 修改了食物效果的实现方式 - 新增了 consumables 系统来处理消耗效果 - 更新了 radish（萝卜）物品的相关效果 4. 其他系统更新： - 更新了数据生成器的实现 - 修复了物品名称显示的问题 - 调整了消息显示系统 最后作者进行了实际测试，确认了大部分功能正常工作，但发现护甲系统可能还存在一些问题需要进一步修复.
 让我为您翻译这段口语化的内容： 21.3 版本确实发生了这些变化，这基本上就是所有在 1.21.3 中的更新了.
对于一直观看到现在的各位，正如我所说，接下来的教程将继续使用 1.21.1 版本.
如果你只是想看完这个视频，或者想了解更新内容，这都完全没问题.
但请注意，我会尽量在 1.21.1 版本的后续教程描述中添加一些说明或注释，说明新版本的变化.
不过我不能保证会完全覆盖，因为仅处理一个版本的三个 API 就已经很繁重了，再加上另外三个版本的内容，虽然不是完全无法完成，但工作量确实很大.
特别是考虑到使用这些新版本的用户群体相对较小，而且我可以告诉你，1.21.1 版本可能会使用很长一段时间.
好了，这就是本次教程的全部内容了.
下一期视频我们将讨论自定义附魔.
希望...