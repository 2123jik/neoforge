让我帮你翻译这段关于 Minecraft 模组开发的文本.
由于这是一段较长的专业教程内容，我会保持技术术语的准确性： 让我们为自定义生物添加变体功能.
在下方链接的 121 个模组开发课程中还有更多深入的 Minecraft 模组开发主题，包括可变实体、可驯服实体、自定义实体装甲，甚至自定义实体物品栏等众多精彩内容.
好的，让我们继续，在本教程中，我们将为我们的实体添加变体，也就是我们的壁虎实体.
在 Blockbench 中我们已经有了壁虎实体，理论上如果你下载了 Blockbench 文件，你就能看到这些内容.
基本思路是这里有所有不同的纹理，这些将成为我们的四种不同变体.
这些不同的纹理现在将作为不同的变体添加，这样它就可以以任何这些不同的颜色生成.
 为此，我们基本上要导出这里所有四种不同的颜色.
我已经完成了这个步骤，我再演示一遍：你需要点击纹理，右键选择"另存为"，然后将其保存为你想要的名称.
在这种情况下，这个将被命名为"gecko_green"，因为这是绿色版本，就是这样.
这就是整个思路，你要导出所有的纹理，随意命名，然后我们可以在 IDE 中继续.
 在 assets/tutorial/textures/entity/gecko 目录下已经有了所有纹理，这里有棕色、绿色和粉色的壁虎颜色.
这将是四种不同的颜色，蓝色显然是我们已经添加的默认颜色.
现在对于变体本身，我们要这样实现：让我们进入实体包，创建一个名为 GeckoVariant 的新 Java 类.
这个类会很有趣，它将是一个枚举类，基本上会列举我们所有的不同变体.
 [由于字数限制，翻译分为两部分.
这是第一部分，包含了主要的实现思路和初始设置步骤.
需要继续翻译剩余的技术细节吗？] 我将为您翻译这段关于《Immersive Translate》中的技术内容描述： 这是一个 values 方法，用于传入流式值.
在第二个括号后进行排序，在 sorted 内部我们要做一个比较器，比较 IntGeoVariant::ID.
在第二个括号后转换为数组，然后传入 GeoVariant，这是一个 GeoVariant 数组 col::new.
这看起来非常复杂，但是如果我们按两次 shift 键查看 HorseVariant，你会发现一些非常有趣的东西.
这实际上只是一个 variant（变体），很有趣，它被称为 variant，你可以看到这几乎是相同的东西.
现在这个实际上有了一个 buyID 映射，所以他们确实为此制作了一个自定义工具类，这很疯狂.
在此之前，他们基本上只有这个也能工作的东西，这是相同的思路，而且非常简单.
无论你有多少个变体，它看起来都会是这样.
理论上我可以有 100 个不同的变体，但这个类的基本设置始终是相同的.
我们还将在这里有一个静态的 geoipVariant，称为 buyID，你传入 ID，然后简单地返回 buyID，再传入 ID 模除 buy_id 的结果.
 让我为这段文本提供中文翻译： 这就是全部内容，这将是完整的变体类或变体枚举，非常简单，这就是你所需要的全部内容.
现在你只需要在有更多变体时添加更多变体，或者如果你有更少的变体，那么就删除它们，这基本上就是你在这种情况下需要做的全部事情.
当然，在这里非常重要的是，这应该是非常基础的 Java 代码，但显然这些变体之间是用逗号分隔的，最后一个以分号结束.
我不知道是否需要再次解释这一点，但你知道，这应该是 Java 基础知识，应该相当容易理解.
这就是变体类或变体枚举，它基本上用于保存这些变体.
 现在问题是我们如何保存变体本身？我们将使用 ID 来保存它，这将在 gecko 实体内部通过以下方式实现：使用一个 private static final 的实体数据访问器，这个访问器的类型是 Integer.
我们将其命名为 variant，它将等于 syncEntityData.Define，并传入 geoipEntity 参数.
 让我为您翻译这段关于《Immersive Translate》中实体数据序列化器的技术文档内容： 这里的第二个参数是实体数据序列化器 int（也称为 int）.
这个概念很有趣.
从最高层面来看，关于实体数据 ESS，您现在需要了解的是：它们是处理特定数据的一种非常简便的方式.
在这个例子中是整数类型，但如果查看序列化器，还可以是其他多种类型，比如 float（浮点数）、string（字符串），甚至是 component（组件）.
这基本上意味着几乎可以是任何类型 - 可以是区块状态（block State）、布尔值（Boolean）等许多不同的数据类型.
 这些数据会在服务器和客户端之间自动同步，这个特性非常实用，因为它使得整个过程变得简单和流畅.
当我们使用这个功能时，需要在 variant 下添加一些内容，因为接下来的大部分内容都与 variant 相关.
首先要注意的是，每当您有一个实体数据访问器时，都需要调用 defineSyncData 方法，并在其中保留 super 关键字，然后使用 builder.
 以下是对输入文本的中文翻译： 定义传入我们拥有的变体，然后是实际的默认值（这里是零）.
如果这个值不存在，那么整个功能就完全无法工作，这一点非常非常重要.
对于变体本身，我们将有三个方法.
这些方法包括一个私有的整型方法 getTypeVariant，它将返回 this.entityData.get，并传入变体参数.
这就是访问实体数据的方式 ―― 你不能直接使用变体本身，而是要使用 entityData.get，然后传入你想要的参数，比如传入实体数据访问器来访问数据.
然后我们有一个公共的 getVariant 方法，这将是我们获取变体的方法，显然是用来获取实际变体的.
实现这个的方式是返回 GeckoVariant，这将是通过 ID 获取 GeckoVariant 枚举，传入 this.
 我将把这段文本翻译成中文，同时保持技术术语的原文形式： 获取类型变体，然后我们将在这里用 255 进行按位与运算.
我仍然不是 100%确定为什么需要这样做，但这与 horse 类中的实现是一样的.
如果我们查看 horse 类（通过 shift 两次，然后选择"include non project items"），再看 get variant 方法，它做的是同样的事情.
我对此有点不确定.
这看起来有点疯狂，我认为这基本上意味着我们最多只能有 255 个变体，不过我觉得这么多变体应该足够了.
在 private void set variant 方法中也是一样的，我们要在这里添加一个 gecko variant 作为参数，这就是我们所说的 this entity data.
 注：保留了技术相关词汇如"variant"、"horse class"、"private void"等术语的原文，以保持专业准确性.
这段翻译保持了原文的技术含义，同时使其对中文读者更容易理解.
 让我帮你翻译这段文本为简体中文： 我们设置变体为 Vari，也就是我们在这里传入的变体，获取 ID 然后再次进行 255 位运算，我认为这样应该没问题，现在我们基本就完成了.
这是用于获取和设置变体的三个方法，现在我们还需要保存变体，并且在一开始就为这个特定实体分配一个变体.
要保存这个，我们需要重写 addAdditionalSaveData 方法以及 readAdditionalSaveData 方法，这两个方法都必须正确重写.
在这里，我们要使用 compound.putInt，我们将在"variant"下保存这个，所以名称就是"variant"，然后第二个参数是我们想要保存的内容，在这种情况下是 getTypeVariant，它实际上就是要获取我们在实体数据中写入的确切内容.
在 readAdditional 中，我们要说 this.entityData.set，然后将变体设置为 compound 中的内容.
 注：保留了代码相关的专有名词如 variant、compound.putInt、getTypeVariant 等不进行翻译，以保持其技术含义.
 这是一段关于游戏开发中实体生成机制的技术说明文本，我将为您翻译： 获取整数并在键变量中再次传入 Ming.
复合标签的工作原理与映射非常相似，您基本上是将某个键映射到某个特定的值.
因此，每当我们保存游戏时，我们会在这里保存变量，然后在读取时将其读出来.
这就是这两个方法所做的全部工作，它们也非常重要且有趣，因为它们可以执行各种不同的操作.
如果需要，您基本上可以在其中保存任何内容.
 最后但同样重要的是，我们要重写 finalizedSpawn 方法，这是我们基本上指定实体生成方式的地方.
当这个特定实体生成时就会调用这个方法，无论是通过刷怪蛋、使用/summon 命令，还是通过正常的生成方式.
在这里，我们要创建一个 geckoVariant，这将是我们的变体，等于 util.random，传入 geckoVariant.values 并传入 this.
 让我为您翻译这段文本： 这里是通过随机方式设置变体，传入变体参数.
基本思路是我们要随机选择一个变体.
在这种情况下，您也可以检查服务器级别的访问器，这实际上就是检查级别，这样您就能确定我们在哪个生物群系中，然后决定要更改该生物群系.
您可以生成群组数据，可以做各种不同的事情.
比如某些壁虎可能只在特定难度下生成，您可以实现所有这些功能.
 此外，当您有两个"父本"时，您可以在 getReadOffspring 方法中进行修改.
因为这里的 create 方法应该返回一个 Geo 实体.
理论上，为了说明问题，我想写出这个示例：这将是幼体，我很确定这样应该可以工作.
然后您可以设置幼体的变体，可以根据这个种群变体（即父本）和另一个父本来设置幼体的变体.
 请记住这完全可行，这基本上意味着您可以根据两个父本的变体来设置变体.
您可以在这里做各种有趣的事情，可以创建一个自定义方法来确定不同变体之间交叉的可能性，这完全取决于您.
我只是想告诉您这是可以实现的.
 实际的底层功能意味着变体现在已经保存，但是如果我们现在进入游戏，它们看起来都完全一样.
为什么会这样呢？这是因为渲染器只知道一种特定的纹理.
我们需要添加一个映射表.
这个映射表看起来可能有点复杂，但很容易理解和解释.
我们要创建一个私有的静态最终映射，这个映射将从 gecko 变体映射到资源位置，我将其命名为 LOCATION_BY_VARIANT，等于 Maps.newEnumMap.
 以下是对输入文本的中文翻译（保持专业术语原文不变）： 传入一个新的 gecko variant 枚举映射.
在第一个右括号后的 gecko variant 类，在第二个右括号后的 map，接着这将是一个消费者，所以你看到 map 后面有一个小箭头，然后我们放入方括号，在这里面我们可以向映射中添加内容.
map.put 方法添加 gecko variant blue，然后在这里我们要指定如果变体是蓝色时对应的资源位置，这将与我们在这里已有的资源位置完全相同，所以我只需要把它剪切出来放在这里，然后用分号结束.
我们可以为绿色、粉色和棕色重复这个过程三次.
当然，指向的资源位置也必须相应更改，所以这里会是 underscore green、gecko underscore pink，然后是 gecko underscore brown.
在 getTextureLocation 方法中，只需要简单地写 locationByVariant.get(entity).
 让我为您翻译这段关于《Immersive Translate》中的内容： 获取变体是因为在获取纹理位置时，我们可以访问到我们正在尝试渲染的 gecko 实体，这意味着我们实际上可以根据实体的不同属性来改变纹理.
比如，我们甚至可以根据实体的生命值来改变纹理，还可以根据生命值改变实体的大小等等，这些都是可能的.
 我认为这非常酷，我希望你能尽可能多地尝试这个功能.
这是我一贯的建议：先让它按照我这里设置的方式正常工作一次.
当然，你可以在下方描述中的 GitHub 仓库查看并确认所有内容都正确.
一旦它能正常工作，就可以尽情发挥创意，尝试各种不同的方案.
 我们现在已经添加了新的纹理，这些纹理将根据自定义实体 gecko 的变体类型来使用.
当我们生成实体时，它会随机选择一个变体.
让我们启动游戏看看是否正常工作.
 好的，我回到 Minecraft 中，让我们看看这里.
如果我生成几个实体，你可以看到它们都是随机变体，这太棒了.
天哪，它们现在变得疯狂起来了.
如果我让它们繁殖，你也可以看到这些应该也是随机的.
有趣的是，所有的幼体看起来都是一样的.
让我实际检查一下，因为我觉得这有点奇怪.
 让我们看看是否所有的幼体都会使用默认变体.
这里又有一个，这两个也是默认变体.
我觉得可能是因为这实际上没有随机化.
让我们在这里仔细检查一下，我很确定它总是使用基础变体.
 显然，我们需要在 getBreedOffspring 方法中也进行检查.
有趣的是，当你使用 getOffspring 时，finalizeSpawn 方法实际上并没有被调用.
但是，解决方案很简单，就是执行以下操作：获取 gecko 实体，将其设为幼体，然后为幼体也随机设置一个变体.
有了这个小改动，现在就能正常工作了.
 看看这里所有这些不同的 gecko！为我们的自定义实体添加了自定义变体，太棒了.
这就是本教程的全部内容，下一个视频我们将在世界中生成实体