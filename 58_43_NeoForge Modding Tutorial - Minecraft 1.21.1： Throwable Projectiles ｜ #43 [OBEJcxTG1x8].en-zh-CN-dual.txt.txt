让我为这段文本提供中文翻译： 让我们深入探讨一下，在我们的 Minecraft 模组中添加一个自定义可投掷的投射物实体.
更多深入的 Minecraft 模组开发主题可以在下方链接的 121 个模组课程中找到，包括可投掷实体、自定义实体装甲，甚至自定义实体物品栏等众多精彩内容.
在本教程中，我们将添加一个自定义可投掷的投射物实体.
虽然这个名字听起来很长，但基本上就是一个我们可以投掷的投射物.
你会发现，尽管本教程的实际长度可能超出预期，但实现起来相对简单.
 在本例中，我们会涉及很多内容.
就像之前几个教程中添加自定义壁虎实体一样，需要编写不少代码.
虽然这次不需要那么多代码，但仍然有相当数量的代码要写.
你可以在描述中找到包含所有代码的 GitHub 仓库链接，随时可以查看.
 我们要添加的是一个非常酷的战斧.
首先，要声明艺术资源的署名权，这些内容遵循知识共享协议发布.
如果你想使用战斧并发布自己的模组，请务必遵守相关许可协议.
 在描述中你可以下载到两个 BlockBench 文件：战斧实体模型和战斧物品模型.
一个是你手持时看到的自定义物品模型，看起来非常棒；另一个则是实体本身，外观略有不同.
 首先，我们需要从 BlockBench 导出这些内容.
对于实体模型，我们需要进入文件->项目，然后选择导出版本 Forge 1.17+，确保选择 MOJ 贴图，然后确认导出 Java 实体文件，这将生成 tomahawk.java 文件.
我们暂时不需要导出动画，因为我们会用不同的方式处理旋转动画效果.
理论上你也可以使用动画方式，但在这个例子中我想用另一种方式实现.
然后在物品模型文件中，选择文件->导出->导出方块/物品模型，生成 tomahawk_item 文件.
 让我为您翻译这段关于《Immersive Translate》中的游戏开发内容： 现在我们需要为两个部分添加材质.
如您所见，它们略有不同.
对于战斧(tomahawk)，右键点击另存为"tomahawk.png".
对于物品模型的材质，右键另存为，我将其命名为"tomahawk-item"，这样我就能区分不同的材质.
导入到 IDE 后我们会重新命名它.
 导出这些内容后，我们就可以开始添加物品了.
实际上从哪里开始并不重要 - 可以先添加物品，也可以先添加实体，因为我们无论如何都需要完整地实现一遍.
 在物品部分，我们需要创建一个自定义物品类.
右键创建一个名为"TomahawkItem"的新 Java 类，它将继承自 Item 类.
添加匹配 super 的构造函数后，我们只需要重写一个方法.
我会复制过来，这里会包含一个预期的错误，因为 TomahawkProjectileEntity 还不存在，不过不用担心.
 当我们右键点击背包中的战斧物品时，这个 use 方法就会被调用，它会生成一个抛射物实体并发射出去.
这里我们使用了雪球投掷的音效.
如果查看原版的雪球物品代码，你会发现实现方式几乎完全相同.
这再次证明了原版代码是很好的参考.
 最后，我们先保留这个错误，因为稍后会注册自定义实体.
现在让我们先注册这个物品，将其声明为`public static final DeferredItem`类型的 tomahawk.
 让我为您翻译这段关于《Immersive Translate》中 Tomahawk 物品注册的内容： 这里要注册的是 Tomahawk（印第安战斧），然后第二个参数是我们刚才用新的物品属性创建的 Tomahawk 物品的供应商.
我认为这个物品应该可以堆叠到 16 个，我觉得这是一个比较合理的平衡方式.
有了这个，我们就可以把它添加到创造模式物品栏中，这是个不错的主意.
所以这就是 Tomahawk 了.
 至于其他内容，我们稍后再处理.
让我们首先添加资源文件，这样我们就基本完成了这部分，之后就可以专注于实体部分.
首先，资源文件中需要添加翻译内容，我们先从物品翻译开始，理论上你也可以为实体添加翻译.
这里也要写上"tomahawk".
虽然我认为我们不太可能遇到需要这个翻译的情况，但为了以防万一，我们也可以加上.
然后说到模型部分，这里我们当然要使用物品模型，也就是 tomahawk 物品的模型.
 让我为您翻译这段关于 Minecraft 模组开发的技术文档内容： 我们要复制这个 JSON 文件并将其重命名为"Tomahawk.json"，以确保与我们在这里注册的名称保持一致.
接下来是非常重要的一点，这也是很多人可能会忘记的：在纹理设置中，你必须明确指定"tutorial_mod:item/tomahawk"作为路径，这一点至关重要，否则将无法正常工作.
 纹理文件将放在 textures/item 目录下，使用从 Blockbench 导出的 tomahawk_item.png 文件.
我们需要确保将其重命名为与这里完全相同的名称.
另一个文件将放在 textures/entity 目录下的新建 tomahawk 文件夹中，即 tomahawk.png.
 关于资源文件的设置就到这里，现在我们可以专注于添加 Tomahawk 实体.
这个实体的实现虽然有点复杂，但我们可以通过几个步骤来解释.
在 entity/custom 目录下，我们将创建 TomahawkProjectileEntity 类，该类继承自 AbstractArrow 类.
选择这个父类的原因稍后就会明显.
 我们需要实现 getDefaultPickupItem 方法，并创建两个构造函数：一个是基础构造函数，另一个是接收射击者（LivingEntity）和世界（Level）参数的构造函数.
在第二个构造函数中，我们调用 super 方法，传入 EntityType、射击者和世界参数，同时创建一个新的物品堆叠实例.
 让我为您翻译这段关于《Immersive Translate》中 Tomahawk（战斧）实现相关的技术文本： Tomahawk（战斧）.
获取之后在第二个右括号后面放置一个 null，因为我们并不是从武器发射这个实体，而是直接投掷它，所以这种情况下从武器发射就简单设为 null.
我们还需要两个自定义字段：一个是名为 rotation（旋转）的 private float 变量，稍后我会解释这两个字段的用途；另一个是非常重要的 Vector2 类型的 groundedOffset（接地偏移量），这个也会稍后说明.
这里 sub 中的内容自然是要从 mod_entities 中获取的实体类型，但只有在 tomahawk 实际注册后才能获取，所以我们稍后再处理这个.
在 getDefaultPickup 中很直接 - 就是创建一个新的 mod_items.Tomahawk 的 ItemStack.
 让我为您翻译这段关于《Immersive Translate》中的游戏实体开发内容： 首先我们获取一些基础方法，然后添加一些自定义方法.
我先复制前三个方法：获取渲染旋转角度(getRendering Rotation)、检查是否着地(isGrounded)以及实体碰撞(onHitEntity)方法.
 让我解释一下获取渲染旋转角度方法，这个我们稍后会用到，主要用于自定义渲染器.
它的作用是让实体的旋转动作更加平滑.
当实体在飞行时，我们希望它能够正确地旋转，这就是该方法的主要功能.
 isGrounded 方法主要是为了让抽象箭类(AbstractArrow)中的 INR 布尔值可以在类外部访问，这是一个辅助方法.
 至于 onEntityHit 方法应该比较好理解，当这个特定实体击中另一个实体时会调用该方法，然后根据设定的数值对目标实体造成伤害.
您可以随意修改这些数值，建议也查看一下抽象箭类中的 onHitEntity 方法的源代码.
 最后一个方法是 onHitBlock，这不是自定义方法，但其内容是自定义的.
这里我们有一个 groundedOffset 向量 2，它根据实体击中方块的不同面来设置.
当实体飞行并击中方块时，无论击中位置在哪里，我们都希望实体能够正确地嵌入方块中.
比如从不同角度击中方块时，都需要正确调整实体的旋转角度，这就是向量 2 和 groundedOffset 的作用 - 确保投斧在方块中的最终位置正确.
 当然，实现这个功能的方法有很多种，有时候可能看起来会有点奇怪.
您完全可以按照自己的想法修改实现方式.
这也是教程的理想使用方式 - 在我提供的基础上进行改进.
 完成这些后，我们就可以在 modEntities 类中注册这个投斧投射物实体了.
我们需要创建一个公共静态 final 的 Supplier，类型是 EntityType，命名为 TOMAHAWK，然后使用 EntityTypes.register 进行注册.
 让我将这段文本翻译为简体中文： builder，然后我们要传入 Tom Hawk 投射物实体::新建 Mob 类别的杂项，在第一个右括号后面是 sized，这里的尺寸将是 0.05 和 1.15，然后在第一个右括号后面再次使用 build，这里有一个 tomahawk 的键值.
现在你会发现在构造函数这里会出现一个错误.
当你创建一个投射物实体或者非生物实体时，你可能之前遇到过也可能没遇到过这个问题.
解决这个问题需要用到一些 Java 虚拟机的魔法代码，我不太清楚为什么这样做有效或者具体是怎么工作的，但基本上你需要在 builder 中这样做.
 让我为您翻译这段文本为简体中文： 在点号之后和尖括号之前，你需要放入要表示的泛型内容.
基本上就是表明"这是某种泛型"，在里面你要传入 Tomo projectile entity（投射物实体），然后它就能正常工作了.
对我来说这种语法非常奇怪，我仍然不太理解为什么它能这样工作.
我的理解是，它很可能是在说"嘿，使用特定的构造函数而不是其他的".
这样说得通，但是确实有点奇怪.
不过这就是它的工作方式，当你这样做的时候，它就能正常工作了.
然后我们可以回到这里的 projectile entity 类中，在构造函数内部设置 mode entities.Tomahawk.
 让我将这段文本翻译为简体中文： 现在这个类已经完成了，你可以关闭它，我们可以回到前面的项目，实际导入 tomog projectile entity.
现在 tomahawk item 类也完成了，我们基本上还剩下两个不同的类需要处理，那就是模型和渲染器.
在 entity client 包中，我们要右键新建一个 Java 类，命名为 tomahawk projectile model，当然还有 client 包中的 Tomahawk projectile renderer.
我们先从模型开始，因为这是我们从 blockbench 导出的.
在这种情况下，我们要复制类的内容，不包括大括号，也就是说只复制大括号内的所有内容.
然后我们需要导入 model location、resource location、model part，以及其他所需的类.
暂时我们先导入所有需要的类，然后再解决可能出现的问题.
 接下来是网格定义，很好，然后把这里的构造函数名称改为类名.
这个类本身不是继承自 entity render，而是要继承自 Entity model，类型是 tomor projectile entity.
然后在这里，我们要修改 setup anim 方法，改为 tomar projectile entity，导入 post stack 和 vertex consumer，最后四个 float 要改为 integer old color，然后在这里我们只需传入那个 color.
这基本上就是我们需要做的全部了.
当然，model location 需要改为 Resource location，包含 namespace 和 path，mod ID 自然是 tutorial mod.
 让我将这段文本翻译为简体中文： 模组 ID Tomahawk 在这种情况下很好，主要层面上来说确实是我们所需要的全部内容.
对于投射物模型来说相当简洁，对吧？这里没有动画，也没有特定的路径或其他我们需要的东西，这就是模型中的所有内容.
渲染器稍微复杂一些，但不用担心.
现在，渲染器将继承自 EntityRenderer 类型的 HoarProjectileEntity，然后我们将悬停在这上面来实现 getTextureLocation 方法，再次悬停来创建匹配 super 的构造函数，这样就可以了.
我们要将其设为 public，然后这里有一个很重要的点，我们需要有一个 private 修饰的 TomahawkProjectileModel，所以我们需要在这里面或多或少地自定义模型，然后当然要在构造函数中将 this.model 设置为一个新的 TomahawkProjectileModel，并传入 context 参数.
 让我将这段关于游戏开发的技术讨论翻译成中文： 烘焙层会在投射物模型中实现.
关于层的位置，这样处理就很好了.
说到纹理位置，我认为不需要详细展开，因为我们之前已经添加过了.
就是我们在实体这里添加的纹理，指向这个位置 - 别忘了 PNG 格式，这是个很容易忽略但非常重要的细节.
 接下来我要复制渲染方法.
这里需要渲染方法，你会发现整体并不复杂.
大部分内容也是从箭矢实体那里借鉴来的.
这里的核心思路是我们有两种不同的处理方式：当投射物着地和未着地时的旋转处理方式不同.
 当未着地时，根据渲染旋转值，我们会在 X 轴正方向上持续旋转.
看这里，X 轴是红色的，所以就是这个红色轴，往正方向旋转就是这个方向.
这个旋转效果会非常炫酷.
这个过程会一直持续到投射物着地为止.
 当着地后，rot 变量会被设置为 y 和 x 的偏移值，这个偏移值取决于投射物击中方块的哪一面.
这就是实体渲染器的基本原理.
 这种实现方式是否最优？我说实话不太确定.
可能直接旋转实体本身，而不是仅在渲染器中旋转会更好.
但我觉得目前这种方式已经够直观了.
当然，不同人可能有不同看法，这完全没问题.
建议你也可以自己尝试实现看看.
 所有代码都在下方供你参考.
现在我们只需要通过 mod 事件系统把所有东西连接起来，首先是注册层，这就是投射物模型.
 让我来将这段文本翻译成简体中文： 层级位置当然也将是 tomaha 抛射物模型，这里没有属性，没有生成配置，因为实际上这个东西并不会生成.
最后一个是在教程模组类的底部，在这里的实体渲染器（entity render us）中.
 注意： - 保留了专有名词 "tomaha" 和 "entity render us" 的原文形式 - 翻译保持了原文的技术语境，使其在游戏开发/模组制作的上下文中依然清晰易懂 - 调整了语序使其符合中文的表达习惯，同时保持了原意完整 让我为您翻译这段文本： 注册 Tomahawk 模组实体，这将用于飞斧投射物渲染器的创建.
我认为现在我们已经拥有了所需的一切.
再次说明，这个过程并不是特别直观，不是说你可以在 5 分钟内就添加完成，但是当你仔细查看时，每个类的实现其实并不太复杂，特别是与壁虎实体相比，后者需要添加更多的内容.
 完成这些后，我们可以直接进入游戏看看效果.
回到 Minecraft 后，你可以看到飞斧已经成功添加到游戏中了.
我可以投掷它，你能看到它在空中旋转的样子，看起来非常酷.
当飞斧击中方块时，它会插在里面，我们甚至可以再次拾取它.
根据击中的面，它的卡入角度可能会有点奇怪，这就是我之前提到的有时可能看起来会很怪异的原因.
比如，如果我特意往地面扔，它就会像这样卡住.
如果我这样投掷，可能看起来有点奇怪，但总的来说，整体效果非常酷炫，特别是当你到处投掷的时候.
当然，你也可以尝试击中实体，这也能完美运作.
 在我看来，这真的非常酷.
这就是自定义可投掷投射物实体添加到 Minecraft 的全过程，非常棒.
本教程到此结束，下一期视频我们将讨论自定义 Boss 血条，希望到时候再见