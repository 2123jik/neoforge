让我们为《我的世界》1.21 版本添加美味食物和燃料.
下面提供了超过 11 小时的《我的世界》模组开发教程，内容涵盖从基础知识到方块实体和自定义生物的所有内容.
 大家好，我是 Neo Forge 的开发者，在本教程中，我们将为《我的世界》添加一个自定义食物和两种自定义燃料.
对于只对其中一项感兴趣的朋友，可以查看视频描述中的时间戳.
当然，所有代码和其他资源也都可以在描述中下载.
 关于燃料，实际上有两种不同的添加方式，这就是为什么我们要添加两种.
不过首先，让我们从食物开始.
要添加自定义食物物品，我们需要创建自定义食物属性.
这些属性基本上决定了营养值、饱食度以及其他一些可以为自定义食物添加的特性.
 这些内容将放在我们的 item 包中.
在那里右键点击新建 Java 类，创建 ModFoodProperties 类.
在这里，我们将创建新的食物属性，即创建一个 public static final 的 FoodProperties，在这个例子中是萝卜（radish），它等于一个新的 food properties 实例.
 让我将这段关于游戏食物系统构建的文本翻译为中文： 我们要选择 Builder，然后开始构建.
首先要调用的方法是营养值，这里设为 3，饱和度修饰符设为 0.25.
你可以看到我们还可以设置"总是可食用"，这样即使在不饿的时候也能吃.
"快速"字面意思就是你可以快速食用这个物品.
而"转化为"则会在食用后将物品转换，比如炖菜会变成碗，这就是这个功能的用途.
最后一项是效果，虽然吃萝卜可能不会给你任何效果，但让我们来添加一个.
这里可以添加一个新的状态效果实例的供应器，传入 mob 效果起始值，然后选择我们想要的效果.
我觉得生命提升效果还挺合理的，让我们设置持续 400 刻度，并有 35%的几率获得这个效果.
 注：保留了专业术语如 Builder、mob effect 等原文，因为这些是游戏开发中的特定术语.
这段文本描述了如何在游戏中配置一个食物物品的属性，包括其营养值、饱和度、食用条件、转化机制以及可能带来的状态效果.
 让我帮你将这段文本翻译成简体中文： 在最后构建时，我们在这里为鱼类添加了食物属性，还有 35%的几率获得生命提升效果.
如果我们想查看原版食物，可以连按两次 Shift 键，然后查看 foods 类（包括非项目物品），这里我们可以看到所有不同的食物构建器以及所有原版食物的相关信息.
强烈建议大家看看这个，然后你就可以根据需要平衡你的食物属性了.
 还有一个很重要的点，如果你想把自定义食物做成饮品，那么对于特定的自定义食物，你需要一个专门的物品类.
我用凿子物品作为例子来演示，你需要重写 getUseAnimation 方法，然后返回一个饮用动画.
这就是一个只重写了这个方法的自定义物品类.
当你在 mod_items 类中创建该物品时，你就使用这个类而不是普通的物品类.
 对于普通物品，我们有一个 public static final 的 DeferredItem类型的萝卜，它通过 items.DeferredRegister 调用 register 方法创建，使用普通 Item 供应器并获取物品属性，这里会调用 food 方法传入 mod_food_properties 中的萝卜属性.
 当然，我们还需要翻译文件和 JSON 文件.
翻译文件没什么特别的，而 JSON 文件我们可以再次通过按住 Control 拖动一个物品模型 JSON 文件到相同文件夹，将名称改为 radish，并确保它指向正确的材质.
说到材质，我们也会复制这个，这些都会在下面提供给你.
 最后别忘了把它添加到创造模式标签页中.
现在我们可以在游戏中尝试我们的萝卜了.
你可以看到萝卜已经被添加到游戏中，而且看起来非常棒，完全就像一个真实的萝卜.
我们当然也可以吃它，你看，我们甚至获得了生命提升效果.
 接下来我们要处理两种不同的燃料，这很有趣因为在 NeoForge 中有两种不同的方式来添加自定义燃料.
我们首先会看使用自定义类的方式，然后再看通过数据映射的方式.
首先在 item.custom 包中，我们右键新建一个 Java 类，这将是我们的燃料物品类.
它会继承 Item 类，我们创建一个匹配的构造函数，在这里我们要做几件事：添加一个私有的整数 burnTime 并将其初始化为 0，同时在构造函数中添加这个参数，然后重写 getBurnTime 方法并返回 this.
 让我帮你翻译这段文本为简体中文： 燃烧时间就是这样，这将是我们的燃料物品，我们可以根据需要，使用任何类型的燃烧时间来重复使用它.
当然，因为这是在这个类中定义的，对吧？我们甚至可以进一步改变它，使其取决于物品是否有与某些组件相关的数据，或者其他任何我们在这种情况下可以实现的东西.
不过这就是我们所需要的全部内容.
然后我们可以回到 mod 物品这里，实际注册它.
public static final 类型为 Item 的物品，这个我实际上得再检查一下是哪一个，这将是 Frost fire uncore ice，等于 items.
 注：保留了代码相关的专有名词如"public static final"、"Item"、"Frost fire uncore ice"和"items"的原文形式.
 让我为您翻译这段文本为简体中文： 注册，当然在这里 Frost fire ice（霜火之冰），我认为也许我们要在这些燃料类型方面做得更偏向奇幻风格，这里当然会有一个新的燃料物品，传入新的物品属性作为第二个参数，燃烧时间以 tick 为单位，在这种情况下是 800，这样我们就已经有了一个可以燃烧的物品，这是这里的第一步，但是我们如何能够用一种不同的方式来做这件事呢？实现不同方式的方法就是简单地添加一个普通物品，所以我们要创建一个 public static final 的 deferred item，类型为 item，这将是我们的 starlightCore（星光核心），等于 items.
 注：保留了专有名词如 "Frost fire ice"、"tick"、"public static final"、"deferred item"、"item"、"starlightCore" 和 "items" 的原始形式，因为这些是编程相关的专业术语或特定名称.
 让我来翻译这段文本： 注册成为 LightCore 灰烬之星，这将是一个新的物品，就是一个具有普通物品属性的普通物品，没有什么特别之处.
你可以看到这有点奇怪，那么我们现在如何向游戏添加这实际上是一种燃料的事实呢？我们要进入数据文件夹，创建一个名为 NeoForge 的新目录（全部是一个词），在该文件夹内创建一个名为 dataor maps 的新目录，然后在其中创建最后一个名为 item 的目录，接着创建一个新文件，这将是熔炉核心燃料.
 让我为这段文本提供中文翻译： 这个 Json 的内容看起来是这样的，这里会有一些值，我们这边会有一些值，比如 tutorial mod 冒号 Starlight ashes，然后是冒号，这里会有一个燃烧时间，在这个例子中我们设为 1200.
如果你想查看原版的燃烧时间值，按两次 Shift 键，然后找到 abstract furnace block entity，往下滚动一点，你应该能找到 buildFuels 方法，在那里你可以看到不同物品和方块及它们对应的燃烧时间（以刻为单位），这也是一个很好的参考资源.
 是的，就是这样.
我们基本上有一些数据映射，Forge 添加了这些功能，使得添加某些东西变得更容易，比如在这个例例子中是燃料.
还有其他类似的东西，比如堆肥机，你可以通过数据映射来实现，诸如此类的东西.
我很确定这些也可以通过数据生成来实现，尽管我还没有尝试过.
这种方式非常酷，而且用这种方法添加东西也相当简单.
 说到物品，我们仍然需要完成物品所需的常规步骤，这没什么特别的.
当然要把它们添加到创造模式标签页中，确保它们有翻译.
然后是物品模型 JSON，只需要拖入一个已存在的物品 JSON 文件，简单重命名，然后修改这里的内容就可以了.
接着我们可以复制两个材质文件，这些当然也会在下方提供给你.
如果我没记错的话，这应该就是我们在这个例子中需要的全部内容了.
 如我所说，添加燃料有两种不同的方式.
让我们进入游戏看看它们是否能燃烧.
如你所见，霜火之冰和星光灰都已成功添加到游戏中.
让我们来看看，这些在高炉中也能燃烧，实际上它们在任何炉子中都能工作.
正如你看到的，所有这些都能正常工作，它们应该能按照我们指定的确切时间燃烧.
显然，我们是以刻为单位定义的，我记得这个是 600 刻，这个是 1200 刻，所以理论上霜火之冰的燃烧时间应该是星光灰的一半.
目测看起来差不多对，虽然我觉得这可能不是 600，可能是另一个数值，但这无关紧要，它们都能燃烧，这才是重点.
 这就是自定义燃料，为 Minecraft 添加完成了.
像往常一样，所有代码都在下方提供，所以完全不用担心.
这就是本次教程的全部内容了，下次视频我们将讨论自定义工具提示，希望到时候能见到你们